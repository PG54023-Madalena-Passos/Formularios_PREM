import mongoose from 'mongoose';
import { randomUUID } from 'crypto';

interface EncounterDocument {
  id: string; // ID do Encounter (ex: "internamento5")
  class: {
    code: string;
  };
  period?: {
    end?: string | Date;
    [key: string]: any;
  };
  [key: string]: any;
}

interface QuestionnaireDocument {
  id: string; // UUID (string)
  code: string;
  createdAt: Date;
  encounterId: string; // Refer√™ncia ao Encounter original
}

const pollInterval = 5000; // Intervalo de polling em milissegundos

export const startEncounterPolling = () => {
  mongoose.connection.once('open', async () => {
    console.log('üîç Polling for new Encounters...');

    const encounterCollection = mongoose.connection.collection('Encounter');
    console.log('‚úÖ Conectado √† cole√ß√£o Encounter');

    let lastChecked = new Date(Date.now() - 60 * 60 * 1000); // 1 hora atr√°s

    setInterval(async () => {
      console.log('üîÑ Iniciando polling para novos Encounters...');
      try {
        const newEncounters = await encounterCollection.find({
          'period.end': { $gt: lastChecked.toISOString() } // Compara√ß√£o como string ISO
        }).toArray();

        console.log(`üîç Encontrados ${newEncounters.length} novos Encounters`);
        lastChecked = new Date();

        const questionnaireCollection = mongoose.connection.collection('Questionnaire');

        for (const encounter of newEncounters) {
          const fullDocument = encounter as unknown as EncounterDocument;

          if (!fullDocument?.class?.code) {
            console.warn('‚ö†Ô∏è Encounter inserido sem class.code. Ignorado.');
            continue;
          }

          if (!fullDocument.id) {
            console.warn('‚ö†Ô∏è Encounter sem id. Ignorado.');
            continue;
          }

          const encounterEnd = fullDocument.period?.end;
          if (!encounterEnd) {
            console.warn('‚ö†Ô∏è Encounter sem period.end. Ignorado.');
            continue;
          }

          const endDate = encounterEnd instanceof Date ? encounterEnd : new Date(encounterEnd);
          if (isNaN(endDate.getTime())) {
            console.warn('‚ö†Ô∏è period.end inv√°lido. Ignorado.');
            continue;
          }

          // Checar se j√° existe um Questionnaire para este Encounter
          const existing = await questionnaireCollection.findOne({
            encounterId: fullDocument.id
          });

          if (existing) {
            console.log(`‚ö†Ô∏è Questionnaire j√° existe para Encounter ${fullDocument.id}. Ignorado.`);
            continue;
          }

          const newQuestionnaire: QuestionnaireDocument = {
            id: randomUUID(), // UUID como campo separado
            code: fullDocument.class.code,
            createdAt: endDate,
            encounterId: fullDocument.id, // Liga√ß√£o ao Encounter
          };

          try {
            await questionnaireCollection.insertOne(newQuestionnaire);
            console.log(`‚úÖ Novo Questionnaire criado: ${newQuestionnaire.id} (code: ${newQuestionnaire.code}, encounterId: ${newQuestionnaire.encounterId})`);
          } catch (error) {
            console.error('‚ùå Erro ao criar Questionnaire:', error);
          }
        }
      } catch (error) {
        console.error('‚ùå Erro ao buscar novos Encounters:', error);
      }
    }, pollInterval);
  });
};
